#!/usr/bin/env python3
"""
Personal AI Employee - Main Orchestrator with HITL Integration

Manages the flow: External Input → Watcher → Needs_Action → HITL_Approver → 
Pending_Approval → Human Approval → Approved → MCP Execution → Done → Logs

HITL Integration:
- Sensitive actions routed to Pending_Approval/
- Orchestrator watches Approved/ folder for execution
- All activities logged to Logs/
"""

import os
import json
import re
import time
import threading
from pathlib import Path
from datetime import datetime
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import subprocess
import sys

# Add Skills to path
sys.path.insert(0, str(Path(__file__).parent / "Skills"))


class ActionHandler(FileSystemEventHandler):
    """
    Handles new action files dropped into the Needs_Action folder.
    Integrates with HITL_Approver for sensitivity detection.
    """

    def __init__(self, vault_path, logs_path, approved_path, hitl_agent=None):
        self.vault_path = Path(vault_path)
        self.logs_path = Path(logs_path)
        self.approved_path = Path(approved_path)
        self.hitl_agent = hitl_agent

    def on_created(self, event):
        if event.is_directory:
            return
        if event.src_path.endswith('.md'):
            print(f"New action file detected: {event.src_path}")
            self.process_action_file(event.src_path)

    def process_action_file(self, file_path):
        """Process a new action file with HITL sensitivity check"""
        try:
            self.log_activity("action_detected", {"file": file_path})

            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            action_type = self._detect_action_type(content, file_path.name)
            recipient_email = self._extract_email(content)

            # Use HITL_Approver if available
            if self.hitl_agent:
                result = self.hitl_agent.request_approval(
                    content=content,
                    action_type=action_type,
                    recipient_email=recipient_email,
                    source_path=Path(file_path)
                )

                if result.get("requires_approval"):
                    print(f"[HITL] Action requires approval: {result.get('approval_id')}")
                    self.log_activity("hitl_approval_requested", {
                        "file": file_path,
                        "approval_id": result.get("approval_id"),
                        "type": action_type,
                    })
                    # Remove from Needs_Action (approval file created in Pending_Approval)
                    try:
                        Path(file_path).unlink()
                    except Exception:
                        pass
                    return
                else:
                    print("[HITL] Action approved for direct execution")

            # Non-sensitive: create plan and move to Approved
            plan_content = self.generate_plan(content, file_path, action_type)
            plan_file = self.create_plan_file(file_path, plan_content)

            self.log_activity("plan_generated, {"input_file": file_path, "output_plan": str(plan_file)})
            print(f"Plan generated: {plan_file}")

        except Exception as e:
            print(f"Error processing action file: {str(e)}")
            self.log_activity("error", {"file": file_path, "error": str(e)})

    def _detect_action_type(self, content: str, filename: str) -> str:
        """Detect action type from content."""
        content_lower = content.lower()
        filename_lower = filename.lower()

        if "linkedin" in content_lower or "linkedin" in filename_lower:
            if "post" in content_lower:
                return "linkedin_post"
            return "linkedin_message"
        elif "email" in content_lower or "@" in content:
            return "email"
        elif "payment" in content_lower or "$" in content:
            return "payment"
        elif "file" in content_lower or "drop" in filename_lower:
            return "file_operation"
        elif "calendar" in content_lower or "meeting" in content_lower:
            return "calendar"
        return "general"

    def _extract_email(self, content: str) -> str:
        """Extract email address from content."""
        match = re.search(r'[\w\.-]+@[\w\.-]+\.\w+', content)
        return match.group(0) if match else None

    def generate_plan(self, content: str, file_path: Path, action_type: str) -> str:
        """Generate execution plan."""
        return f"""# Execution Plan

**Source:** {file_path.name}
**Type:** {action_type}
**Generated:** {datetime.now().isoformat()}

---

## Content
{content}

---

## Status
- Status: APPROVED (non-sensitive)
- Execution: PENDING

---
*Generated by Orchestrator | Personal AI Employee*
"""

    def create_plan_file(self, original_file_path: Path, plan_content: str) -> Path:
        """Create a plan file in Approved/."""
        original_filename = Path(original_file_path).stem
        plan_filename = f"{original_filename}_plan.md"
        plan_path = self.approved_path / plan_filename

        with open(plan_path, 'w', encoding='utf-8') as f:
            f.write(plan_content)

        return plan_path

    def log_activity(self, activity_type: str, details: dict):
        """Log activities."""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "activity_type": activity_type,
            "details": details
        }
        log_file = self.logs_path / f"activity_{datetime.now().strftime('%Y%m%d')}.jsonl"
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(json.dumps(log_entry) + '\n')


class ApprovedActionHandler(FileSystemEventHandler):
    """
    Watches Approved/ folder and triggers MCP execution.
    """

    def __init__(self, approved_path, done_path, logs_path):
        self.approved_path = Path(approved_path)
        self.done_path = Path(done_path)
        self.logs_path = Path(logs_path)
        self.executed = set()

    def on_created(self, event):
        if event.is_directory:
            return
        if event.src_path.endswith('.md'):
            print(f"Approved action detected: {event.src_path}")
            self.execute_action(event.src_path)

    def execute_action(self, file_path: Path):
        """Execute an approved action via MCP."""
        if str(file_path) in self.executed:
            print(f"[SKIP] Already executed: {file_path.name}")
            return

        try:
            print(f"[MCP] Executing: {file_path.name}")

            # Read the approval/plan file
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Extract action type
            type_match = re.search(r"(?:type|Type):\s*(\w+)", content)
            action_type = type_match.group(1) if type_match else "general"

            # Simulate MCP execution
            exec_result = self._simulate_mcp_execution(action_type, content)

            # Update status
            updated_content = content.replace(
                "Execution: PENDING",
                f"Execution: COMPLETED\n**Executed At:** {datetime.now().isoformat()}"
            )

            # Move to Done/
            done_path = self.done_path / file_path.name
            with open(done_path, 'w', encoding='utf-8') as f:
                f.write(updated_content)

            # Remove from Approved/
            try:
                file_path.unlink()
            except Exception:
                pass

            self.executed.add(str(file_path))

            # Log
            self.log_activity("action_executed", {
                "file": file_path.name,
                "type": action_type,
                "result": exec_result,
            })

            print(f"[DONE] Moved to Done/: {done_path.name}")

        except Exception as e:
            print(f"[ERROR] Execution failed: {e}")
            self.log_activity("execution_error", {"file": str(file_path), "error": str(e)})

    def _simulate_mcp_execution(self, action_type: str, content: str) -> dict:
        """Simulate MCP server execution."""
        mcp_servers = {
            "email": "email-mcp",
            "linkedin_post": "browser-mcp",
            "linkedin_message": "browser-mcp",
            "payment": "payment-mcp",
            "calendar": "calendar-mcp",
            "file_operation": "file-mcp",
        }
        server = mcp_servers.get(action_type, "general-mcp")

        return {
            "server": server,
            "status": "simulated_success",
            "timestamp": datetime.now().isoformat(),
        }

    def log_activity(self, activity_type: str, details: dict):
        """Log activities."""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "activity_type": activity_type,
            "details": details
        }
        log_file = self.logs_path / f"activity_{datetime.now().strftime('%Y%m%d')}.jsonl"
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(json.dumps(log_entry) + '\n')


def main(stop_event=None):
    """Main entry point for the orchestrator."""
    base_path = Path(__file__).parent
    needs_action_path = base_path / "Needs_Action"
    vault_path = base_path / "Vault"
    logs_path = base_path / "Logs"
    approved_path = base_path / "Approved"
    done_path = base_path / "Done"
    pending_approval_path = base_path / "Pending_Approval"

    # Ensure directories exist
    for path in [vault_path, logs_path, approved_path, done_path, pending_approval_path]:
        path.mkdir(parents=True, exist_ok=True)

    # Initialize HITL Approver
    try:
        from Skills.HITL_Approver.agent import HITLApproverAgent
        hitl_agent = HITLApproverAgent()
        print("[HITL] HITL Approver initialized")
    except Exception as e:
        print(f"[HITL] Could not initialize: {e}")
        hitl_agent = None

    # Create handlers
    action_handler = ActionHandler(
        vault_path, logs_path, approved_path, hitl_agent
    )
    approved_handler = ApprovedActionHandler(approved_path, done_path, logs_path)

    # Set up observers
    action_observer = Observer()
    action_observer.schedule(action_handler, str(needs_action_path), recursive=False)

    approved_observer = Observer()
    approved_observer.schedule(approved_handler, str(approved_path), recursive=False)

    print("=" * 60)
    print("AI Employee Orchestrator with HITL Integration")
    print("=" * 60)
    print(f"Monitoring: {needs_action_path}")
    print(f"Monitoring: {approved_path}")
    print(f"Vault: {vault_path}")
    print(f"Logs: {logs_path}")
    print("=" * 60)

    # Start observers
    action_observer.start()
    approved_observer.start()

    try:
        print("Orchestrator running. Press Ctrl+C to stop.")
        while not (stop_event and stop_event.is_set()):
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nShutting down orchestrator...")

    action_observer.stop()
    approved_observer.stop()
    action_observer.join(timeout=2)
    approved_observer.join(timeout=2)


if __name__ == "__main__":
    main()
